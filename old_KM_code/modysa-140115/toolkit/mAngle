#!/usr/bin/env python

from modysa.io import index as NDX
import modysa.misc as M
import numpy as N
import os.path as OP
from modysa.io import trajectory as T
from modysa import statistics as S
from modysa.core import geometry as G
from modysa.core import configuration as C

def main(fn_ndx=None, fn_xtc=None, suffix='_400-1200.dat', norm=None,
         first=400000, last=1199999, block_steps=5e5, signed=False,
         hist_range=None, verbose=False):
    """norm, e.g.: [1,1,0] or [0,0,1]
    signed: False (-pi,pi) True (0, pi)
    """
    # FIXME: convert block_steps into time, i.e. 5e5 into 1000 ns

    assert None not in [fn_ndx, fn_xtc]
    # inspect.getcallargs new in 2.7
    loc = locals()
    for item in ['fn_ndx', 'fn_xtc', 'suffix', 'norm',
                 'first', 'last', 'block_steps', 'signed']:
        print '%20s :: %s' % (item, str(loc[item]))
    #
    if norm is not None:
        # FIXME: norm should be vector normal to the surface
        #        and not be a vector in the chosen plane 
        surface = G.Vector()
        surface(norm)
    #
    ndx = NDX.IndexFile()
    ndx.read(fn_ndx)
    for gn in ndx.getGroups(str): ndx.lists(gn)

    # SANITY CHECK:
    # first column should have two atom indices (vector begining-end)
    # second column: either two atom indices or three-element list describing
    #           reference vector (two modes cannot be mixed in one group def)
    
    names = ndx.groups.keys()
    vec = {}
    for gn in names:
        columns = zip(*ndx.groups[gn])
        assert len(columns) == 3, \
            'Error: three columns expected in the class %s' % str(gn)
        v1, v2, v3 = map(N.array, columns)
        assert v1.shape[-1] == 2, \
            'Error: two atom indices expected in 1st group %s' % str(gn)
        if v2.shape[-1] == 3: MODE = 'reference'  # angle vs. given vector
        else:
            assert v2.shape[-1] == 2, \
                'Error: two atom indices expected in the 2nd group %s' % str(gn)
            MODE = 'paired' # angle between two two-atom vectors
            # FEATURE: a1 a2 a3 vs. a1 a2 | a2 a3 (in general
            # a2 might be different in both vectors)
        assert v3.shape[-1] == 3, \
            'Error: reference vector expected but not found'
        assert v1.shape[0] == v2.shape[0] == v3.shape[0], \
            'Error: number of vectors mismatch found in the class %s' % str(gn)
        v1 -= 1  # atoms numbering 0..n-1 from 1..n
        dv1 = G.DistanceVector(v1.tolist())
        if MODE == 'paired': 
            v2 -= 1
            dv2 = G.DistanceVector(v2.tolist())
        else: 
            dv2 = G.Vector()
            dv2(v2.tolist())
        dv3 = G.Vector()
        dv3(v3.tolist())
        vec[gn] = (dv1, dv2, dv3)
        
    # check presence of output files
    for name in names:
        out_fnm = '%s-H%s' % (name,suffix)  # histogram
        assert not OP.lexists(out_fnm), 'rename/remove %s' % out_fnm
        out_fnm = '%s-S%s' % (name,suffix)  # block averages
        assert not OP.lexists(out_fnm), 'rename/remove %s' % out_fnm
        
    # open coord trajectory
    traj = T.Trajectory(fn_xtc)
    traj.limit(first, last)
    step1st = traj.getStep()
    conf = None
    proceed = True
    cell = C.Cell()

    # init storage of results
    cumhist = {}
    blkhist = {}
    rfh = {}

    for name in names:
        if hist_range: bins = N.arange(*hist_range)
        else: 
            if signed: amin = -180.
            else: amin = 0.0
            bins = N.arange(amin,180.,0.1)
        cumhist[name] = S.Histogram(periodic=True)
        cumhist[name].set(bins=bins)
        blkhist[name] = S.Histogram(periodic=True)
        blkhist[name].set(bins=bins)
        rfh[name] = open('%s-S%s' % (name, suffix), 'w')

    while proceed:
        xyz = traj.getConfiguration()
        cell.setFromBasisVectors(traj.getCell())
    
        if conf is None: conf = C.Configuration(xyz, cell)
        else: conf.update(xyz, cell)

        for name in names:
            v1, v2, v3 = vec[name]
            v1(conf)
            if norm: v1.projection(surface)
            if isinstance(v2, G.DistanceVector): v2(conf)
            a = v1.angle(v2,reference=v3)
            if not signed: a = N.abs(a) # (0,pi) range instead of (-pi,pi)
            blkhist[name].addData(a/M.Units.deg)   # [deg]

        step = traj.getStep()
        if (step - step1st) > 0 and (step - step1st) % block_steps == 0:
            frame_time = traj.getTime()
            for name in names:
                cumhist[name].update(blkhist[name])
                # FIXME: periodic data series...
                # S.Histogram.mean/mode
                gj = blkhist[name]()
                values = (frame_time, blkhist[name].mean,
                          blkhist[name].standardDeviation)
                blkhist[name].reset()
                rfh[name].write('%12.2f %12.5f %12.5f\n' % values)
                rfh[name].flush()

        # read next frame
        proceed = traj.readFrame()

    # flush remaining block averages
    if N.any(blkhist[name].data):
        frame_time = traj.getTime()
        for name in names:
            cumhist[name].update(blkhist[name])
            gj = blkhist[name]()
            values = (frame_time, blkhist[name].mean, 
                      blkhist[name].standardDeviation)
            rfh[name].write('%12.2f %12.5f %12.5f\n' % values)
            rfh[name].close()

    # save histograms
    for name in names:
        out_fnm = '%s-H%s' % (name,suffix)
        bins = cumhist[name].bins.tolist() + [180.]
        data = cumhist[name](1.0).tolist() # normalize area under curve
        data.append(data[0])
        N.savetxt(out_fnm, zip(bins,data), fmt='%10.3f %12.5e')

    traj.close()

if __name__ == '__main__':
    from modysa.io import settings as STG
    import sys
    infile = STG.InputFile()
    infile.load(sys.argv[1])
    fields = infile.entries(fn_ndx=str, fn_xtc=str, first=float, last=float,
                            signed=int, hist_range=tuple, suffix=str, 
                            norm=tuple, block_steps=float)
    infile.show(fields)
    if fields: main(**fields)

