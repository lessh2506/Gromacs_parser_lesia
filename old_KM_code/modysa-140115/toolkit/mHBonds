#!/usr/bin/python2.7

from modysa.io import index as NDX
import modysa.misc as M
from modysa.io import trajectory as T
from modysa.core import configuration as C
from modysa.analyse import interactions as I
from modysa.io import hbonds as HBT

import itertools as IT, re, os.path

def main(fn_ndx=None, fn_xtc=None, suffix=None, first=None, last=None,
         block_steps=50e3, verbose=False):
         # block_steps of 50e3 corresponds to 100 ps for XYZ traj sampled at 2ps 
    assert None not in [fn_ndx, fn_xtc]
    traj = T.Trajectory(fn_xtc)
    traj.limit(first, last)
    first, last = traj.first, traj.last
    # --- print out exec settings
    loc = locals()
    for item in ['fn_ndx', 'fn_xtc', 'first', 'last', 'suffix', 'block_steps']:
        print '%20s :: %s' % (item, str(loc[item]))
    # ---
    # --- parse IndexFile
    ndx = NDX.IndexFile()
    ndx.read(fn_ndx)
    # handle lists/loops
    for gn in ndx.getGroups(str): ndx.lists(gn) 
    # all required groups present?
    oplist = ['donor_atoms','acceptor_atoms', 'H_counts','H_atoms',
              'molecules','pairs', 'exclusions']
    assert ndx.valid(*oplist), 'Error: Missing groups in IndexFile'

    # handle two-element combinations for pairs and exclusions
    for gn in ('pairs', 'exclusions'):
        data = ndx.groups[gn]
        if not data: continue
        combinations = []
        for setA, setB in zip(*data):
            combinations.extend(IT.product(setA, setB))
        ndx.groups[gn] = combinations

    # FIXME: spurious dimension resulting from processing loops
    # i.e. [([1,2,3],),...] instead of [(1,2,3), ...]
    for gn in ('donor_atoms','acceptor_atoms', 'H_counts','H_atoms'):
        # only one-level flat is needed thus full is False
        ndx.flat(gn,full=False) 

    # ensure presence of flat tuples in molecules 
    # i.e.   [(donor_id, acceptor_id), ..] instead of 
    # [([donor_id], [acceptor_id]), ..]
    donors, acceptors = zip(*ndx.groups['molecules'])
    nitdon = map(M.isiterable, donors).count(True)
    nitacc = map(M.isiterable, acceptors).count(True)
    if nitdon > 0:
        assert nitdon == len(donors), \
            'Error: Invalid definition of molecules'
        donors = M.flatten(donors, full=True)
    if nitacc > 0:
        assert nitdon == len(acceptors), \
            'Error: Invalid definition of molecules'
        acceptors = M.flatten(acceptors, full=True)
    assert len(donors) == len(acceptors), \
        'Error: mismatch of donor and acceptors numbers in molecules'
    m = zip(donors, acceptors)
    ndx.groups['molecules'] = m

    # prepare arguments for modysa.analyse.interactions.HydrogenBonds
    # order matters! FIXME: consider using keywords here - less error prone
    opargs = tuple([ndx.groups[k] for k in oplist])
    hb = I.HydrogenBonds(*opargs)

    # prepare empty HBond Trajectory files
    if re.match('.+\..+?$', fn_ndx): 
        fn_hbt = '%s%s.hbt' % (re.sub('\.[^\.]+?$','', fn_ndx),suffix)
    else: fn_hbt = '%s%s.hbt' % (fn_ndx,suffix)
    assert not os.path.lexists(fn_hbt), 'netCDF file alread exists!'

    # set step from configuration trajectory
    hbtraj = HBT.HBTrajectory(step=traj.dt)
    hbtraj.open(fn_hbt,'w')

    # open coord trajectory
    step1st = traj.getStep()
    conf = None
    proceed = True
    cell = C.Cell()

    result = []
    while proceed:
        xyz = traj.getConfiguration()
        cell.setFromBasisVectors(traj.getCell())
    
        if conf is None: conf = C.Configuration(xyz, cell)
        else: conf.update(xyz, cell)

        frame_time = traj.getTime()
        frame_step = traj.getStep()

        hb(conf)
        hbtraj.add(hb.data, frame_time)

        if (frame_step - step1st) > 0 and \
                (frame_step - step1st) % block_steps == 0:
            hbtraj.sync()

        # ok, proceed to the next frame
        proceed = traj.readFrame()
    if hbtraj.data: hbtraj.sync()
    hbtraj.close()

    


if __name__ == '__main__':

    from modysa.io import settings as STG
    import sys

    infile = STG.InputFile()
    infile.load(sys.argv[1])
    
    fields = infile.entries(fn_ndx=str, fn_xtc=str, first=float, last=float,
                            suffix=str, block_steps=float)
    infile.show(fields)
    if fields: main(**fields)
